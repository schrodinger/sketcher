diff --git a/Code/GraphMol/Chirality.cpp b/Code/GraphMol/Chirality.cpp
index cf500a932..956e530cd 100644
--- a/Code/GraphMol/Chirality.cpp
+++ b/Code/GraphMol/Chirality.cpp
@@ -1450,7 +1450,9 @@ void findAtomNeighborsHelper(const ROMol &mol, const Atom *atom,
 //   4) three ring neighbors with two different ranks
 //     example for this last one: C[C@H]1CC2CCCC3CCCC(C1)[C@@H]23
 // Note that N atoms are only candidates if they are in a 3-ring
-bool atomIsCandidateForRingStereochem(const ROMol &mol, const Atom *atom) {
+bool atomIsCandidateForRingStereochem(
+    const ROMol &mol, const Atom *atom,
+    const std::vector<unsigned int> &atomRanks) {
   PRECONDITION(atom, "bad atom");
   bool res = false;
   std::set<unsigned int> nbrRanks;
@@ -1474,23 +1476,20 @@ bool atomIsCandidateForRingStereochem(const ROMol &mol, const Atom *atom) {
         } else {
           const Atom *nbr = bond->getOtherAtom(atom);
           ringNbrs.push_back(nbr);
-          unsigned int rnk = 0;
-          nbr->getPropIfPresent(common_properties::_CIPRank, rnk);
-          nbrRanks.insert(rnk);
+          nbrRanks.insert(atomRanks[nbr->getIdx()]);
         }
       }
-      unsigned int rank1 = 0, rank2 = 0;
+      // std::cerr << "!!!! " << atom->getIdx() << " " << nbrRanks.size() << " "
+      //           << ringNbrs.size() << " " << nonRingNbrs.size() << std::endl;
       switch (nonRingNbrs.size()) {
         case 2:
-          if (nonRingNbrs[0]->getPropIfPresent(common_properties::_CIPRank,
-                                               rank1) &&
-              nonRingNbrs[1]->getPropIfPresent(common_properties::_CIPRank,
-                                               rank2)) {
-            res = rank1 != rank2;
-          }
+          // they have to be different
+          res = atomRanks[nonRingNbrs[0]->getIdx()] !=
+                atomRanks[nonRingNbrs[1]->getIdx()];
+
           break;
         case 1:
-          if (ringNbrs.size() >= 2) {
+          if (ringNbrs.size() > nbrRanks.size()) {
             res = true;
           }
           break;
@@ -1507,6 +1506,7 @@ bool atomIsCandidateForRingStereochem(const ROMol &mol, const Atom *atom) {
           res = false;
       }
     }
+    // std::cerr<<"    candidate? "<<res<<std::endl;
     atom->setProp(common_properties::_ringStereochemCand, res, 1);
   }
   return res;
@@ -1515,7 +1515,8 @@ bool atomIsCandidateForRingStereochem(const ROMol &mol, const Atom *atom) {
 // finds all possible chiral special cases.
 // at the moment this is just candidates for ring stereochemistry
 void findChiralAtomSpecialCases(ROMol &mol,
-                                boost::dynamic_bitset<> &possibleSpecialCases) {
+                                boost::dynamic_bitset<> &possibleSpecialCases,
+                                const std::vector<unsigned int> &atomRanks) {
   PRECONDITION(possibleSpecialCases.size() >= mol.getNumAtoms(),
                "bit vector too small");
   possibleSpecialCases.reset();
@@ -1534,7 +1535,7 @@ void findChiralAtomSpecialCases(ROMol &mol,
     if (atom->getChiralTag() == Atom::CHI_UNSPECIFIED ||
         atom->hasProp(common_properties::_CIPCode) ||
         !mol.getRingInfo()->numAtomRings(atom->getIdx()) ||
-        !atomIsCandidateForRingStereochem(mol, atom)) {
+        !atomIsCandidateForRingStereochem(mol, atom, atomRanks)) {
       continue;
     }
     // do a BFS from this ring atom along ring bonds and find other
@@ -1566,7 +1567,7 @@ void findChiralAtomSpecialCases(ROMol &mol,
       atomsSeen.set(ratom->getIdx());
       if (ratom->getChiralTag() != Atom::CHI_UNSPECIFIED &&
           !ratom->hasProp(common_properties::_CIPCode) &&
-          atomIsCandidateForRingStereochem(mol, ratom)) {
+          atomIsCandidateForRingStereochem(mol, ratom, atomRanks)) {
         int same = (ratom->getChiralTag() == atom->getChiralTag()) ? 1 : -1;
         ringStereoAtoms.push_back(same * (ratom->getIdx() + 1));
         INT_VECT oringatoms(0);
@@ -2369,10 +2370,6 @@ void legacyStereoPerception(ROMol &mol, bool cleanIt,
   }
 
   if (cleanIt) {
-    // if the ranks are needed again, this will force them to be
-    // re-calculated based on the stereo calculated above.
-    // atomRanks.clear();
-
     for (auto atom : mol.atoms()) {
       if (atom->hasProp(common_properties::_ringStereochemCand)) {
         atom->clearProp(common_properties::_ringStereochemCand);
@@ -2382,7 +2379,7 @@ void legacyStereoPerception(ROMol &mol, bool cleanIt,
       }
     }
     boost::dynamic_bitset<> possibleSpecialCases(mol.getNumAtoms());
-    Chirality::findChiralAtomSpecialCases(mol, possibleSpecialCases);
+    Chirality::findChiralAtomSpecialCases(mol, possibleSpecialCases, atomRanks);
 
     for (auto atom : mol.atoms()) {
       if (atom->getChiralTag() != Atom::CHI_UNSPECIFIED &&
diff --git a/Code/GraphMol/FindStereo.cpp b/Code/GraphMol/FindStereo.cpp
index 82695fd31..83304732f 100644
--- a/Code/GraphMol/FindStereo.cpp
+++ b/Code/GraphMol/FindStereo.cpp
@@ -818,15 +818,17 @@ bool updateAtoms(ROMol &mol, const std::vector<unsigned int> &aranks,
             needAnotherRound = true;
           }
           sinfos.push_back(std::move(sinfo));
-        } else if (possibleAtoms[aidx]) {
+        } else {
+          // Only do another round if we change anything here
+          needAnotherRound |= possibleAtoms[aidx];
           possibleAtoms[aidx] = 0;
           atomSymbols[aidx] = getAtomCompareSymbol(*atom);
-          needAnotherRound = true;
 
           // if this was creating possible ring stereo, update that info now
           if (possibleRingStereoAtoms[aidx]) {
             --possibleRingStereoAtoms[aidx];
             if (!possibleRingStereoAtoms[aidx]) {
+              needAnotherRound = true;
               // we're no longer in any ring with possible ring stereo. Go
               // update all the other atoms/bonds in rings that we're in:
               for (unsigned int ridx = 0;
@@ -834,15 +836,26 @@ bool updateAtoms(ROMol &mol, const std::vector<unsigned int> &aranks,
                 const auto &aring = mol.getRingInfo()->atomRings()[ridx];
                 unsigned int nHere = 0;
                 for (auto raidx : aring) {
-                  if (possibleRingStereoAtoms[raidx]) {
-                    --possibleRingStereoAtoms[raidx];
-                    if (possibleRingStereoAtoms[raidx]) {
-                      ++nHere;
-                    }
-                  }
+                  // Ring stereo changed, so un-fix atoms in this ring so we can
+                  // recheck them in the next iteration, for the case that they
+                  // are no longer after the current atom was declared
+                  // non-chiral
+                  fixedAtoms[raidx] = false;
+                  nHere += (possibleRingStereoAtoms[raidx] > 0);
                 }
                 if (nHere <= 1) {
-                  // update the bondstereo counts too
+                  // if the ring can't transmit stereo anymore, update the
+                  // counts
+                  if (nHere == 1) {
+                    // update the last potential ring stereo atom in the ring,
+                    // since it can't have ring stereo alone.
+                    for (auto raidx : aring) {
+                      if (possibleRingStereoAtoms[raidx]) {
+                        --possibleRingStereoAtoms[raidx];
+                        break;
+                      }
+                    }
+                  }
                   for (auto rbidx : mol.getRingInfo()->bondRings()[ridx]) {
                     if (possibleRingStereoBonds[rbidx]) {
                       --possibleRingStereoBonds[rbidx];
@@ -1032,6 +1045,10 @@ void cleanMolStereo(ROMol &mol, const boost::dynamic_bitset<> &fixedAtoms,
 }
 }  // namespace
 
+void findChiralAtomSpecialCases(ROMol &mol,
+                                boost::dynamic_bitset<> &possibleSpecialCases,
+                                const std::vector<unsigned int> &atomRanks);
+
 std::vector<StereoInfo> runCleanup(ROMol &mol, bool flagPossible,
                                    bool cleanIt) {
   // This potentially does two passes of "canonicalization" to identify
@@ -1121,13 +1138,14 @@ std::vector<StereoInfo> runCleanup(ROMol &mol, bool flagPossible,
     const bool breakTies = false;
     const bool includeAtomMaps = false;
     const bool includeChiralPresence = false;
+    const bool useRingStereo = false;
     // Now apply the canonical atom ranking code with basic connectivity
     // invariants The necessary condition for chirality is that an atom's
     // neighbors must have unique ranks
     Canon::rankFragmentAtoms(mol, aranks, atomsInPlay, bondsInPlay,
                              &atomSymbols, &bondSymbols, breakTies,
                              includeChirality, includeIsotopes, includeAtomMaps,
-                             includeChiralPresence);
+                             includeChiralPresence, useRingStereo);
 #endif
     // check if any new atoms definitely now have stereo; do another loop if
     // so
@@ -1209,10 +1227,11 @@ std::vector<StereoInfo> runCleanup(ROMol &mol, bool flagPossible,
       const bool includeIsotopes = false;
       const bool includeAtomMaps = false;
       const bool includeChiralPresence = false;
-      Canon::rankFragmentAtoms(mol, aranks, atomsInPlay, bondsInPlay,
-                               &atomSymbols, &bondSymbols, breakTies,
-                               includeChirality, includeIsotopes,
-                               includeAtomMaps, includeChiralPresence);
+      const bool useRingStereo = false;
+      Canon::rankFragmentAtoms(
+          mol, aranks, atomsInPlay, bondsInPlay, &atomSymbols, &bondSymbols,
+          breakTies, includeChirality, includeIsotopes, includeAtomMaps,
+          includeChiralPresence, useRingStereo);
 #endif
       needAnotherRound = updateAtoms(
           mol, aranks, atomSymbols, possibleAtoms, knownAtoms, fixedAtoms,
@@ -1222,6 +1241,10 @@ std::vector<StereoInfo> runCleanup(ROMol &mol, bool flagPossible,
                       knownAtoms, knownBonds, fixedBonds, res);
     }
   }
+
+  boost::dynamic_bitset<> possibleSpecialCases(mol.getNumAtoms());
+  findChiralAtomSpecialCases(mol, possibleSpecialCases, aranks);
+
   for (const auto atom : mol.atoms()) {
     atom->setProp<unsigned int>(common_properties::_ChiralAtomRank,
                                 aranks[atom->getIdx()], true);
diff --git a/Code/GraphMol/SmilesParse/CanonicalizeStereoGroups.cpp b/Code/GraphMol/SmilesParse/CanonicalizeStereoGroups.cpp
index 80f762c8b..670c24204 100644
--- a/Code/GraphMol/SmilesParse/CanonicalizeStereoGroups.cpp
+++ b/Code/GraphMol/SmilesParse/CanonicalizeStereoGroups.cpp
@@ -970,10 +970,12 @@ void canonicalizeStereoGroups(std::unique_ptr<ROMol> &mol,
   const bool useNonStereoRanks = false;
   const bool includeChiralPresence = true;
   const bool includeStereoGroups = false;
+  const bool includeRingStereo = false;
 
   Canon::rankMolAtoms(*mol, ranks, breakTies, includeChirality, includeIsotopes,
                       includeAtomMaps, includeChiralPresence,
-                      includeStereoGroups, useNonStereoRanks);
+                      includeStereoGroups, useNonStereoRanks,
+                      includeRingStereo);
 
   for (auto atom : mol->atoms()) {
     atom->setProp(common_properties::_CanonicalRankingNumber,
diff --git a/Code/GraphMol/new_canon.cpp b/Code/GraphMol/new_canon.cpp
index a40623139..70e8c3ebd 100644
--- a/Code/GraphMol/new_canon.cpp
+++ b/Code/GraphMol/new_canon.cpp
@@ -245,7 +245,7 @@ void compareRingAtomsConcerningNumNeighbors(Canon::canon_atom *atoms,
 namespace detail {
 template <typename T>
 void rankWithFunctor(T &ftor, bool breakTies, int *order, bool useSpecial,
-                     bool useChirality,
+                     bool useChirality, bool includeRingStereo,
                      const boost::dynamic_bitset<> *atomsInPlay,
                      const boost::dynamic_bitset<> *bondsInPlay) {
   PRECONDITION(order, "bad pointer");
@@ -297,7 +297,7 @@ void rankWithFunctor(T &ftor, bool breakTies, int *order, bool useSpecial,
       ties = true;
     }
   }
-  if (useChirality && ties) {
+  if (useChirality && ties && includeRingStereo) {
     SpecialChiralityAtomCompareFunctor scftor(atoms, mol, atomsInPlay,
                                               bondsInPlay);
     ActivatePartitions(nAts, order, count.get(), activeset, next.get(),
@@ -760,7 +760,8 @@ void updateAtomNeighborNumSwaps(
 void rankMolAtoms(const ROMol &mol, std::vector<unsigned int> &res,
                   bool breakTies, bool includeChirality, bool includeIsotopes,
                   bool includeAtomMaps, bool includeChiralPresence,
-                  bool includeStereoGroups, bool useNonStereoRanks) {
+                  bool includeStereoGroups, bool useNonStereoRanks,
+                  bool includeRingStereo) {
   if (!mol.getNumAtoms()) {
     return;
   }
@@ -777,13 +778,14 @@ void rankMolAtoms(const ROMol &mol, std::vector<unsigned int> &res,
   AtomCompareFunctor ftor(&atoms.front(), mol);
   ftor.df_useIsotopes = includeIsotopes;
   ftor.df_useChirality = includeChirality;
-  ftor.df_useChiralityRings = includeChirality;
+  ftor.df_useChiralityRings = includeChirality && includeRingStereo;
   ftor.df_useAtomMaps = includeAtomMaps;
   ftor.df_useNonStereoRanks = useNonStereoRanks;
   ftor.df_useChiralPresence = includeChiralPresence;
 
   auto order = std::make_unique<int[]>(mol.getNumAtoms());
-  detail::rankWithFunctor(ftor, breakTies, order.get(), true, includeChirality);
+  detail::rankWithFunctor(ftor, breakTies, order.get(), true, includeChirality,
+                          includeRingStereo);
 
   for (unsigned int i = 0; i < mol.getNumAtoms(); ++i) {
     res[order[i]] = atoms[order[i]].index;
@@ -801,7 +803,7 @@ void rankFragmentAtoms(const ROMol &mol, std::vector<unsigned int> &res,
                        const std::vector<std::string> *bondSymbols,
                        bool breakTies, bool includeChirality,
                        bool includeIsotopes, bool includeAtomMaps,
-                       bool includeChiralPresence) {
+                       bool includeChiralPresence, bool includeRingStereo) {
   PRECONDITION(atomsInPlay.size() == mol.getNumAtoms(), "bad atomsInPlay size");
   PRECONDITION(bondsInPlay.size() == mol.getNumBonds(), "bad bondsInPlay size");
   PRECONDITION(!atomSymbols || atomSymbols->size() == mol.getNumAtoms(),
@@ -833,7 +835,7 @@ void rankFragmentAtoms(const ROMol &mol, std::vector<unsigned int> &res,
 
   auto order = std::make_unique<int[]>(mol.getNumAtoms());
   detail::rankWithFunctor(ftor, breakTies, order.get(), true, includeChirality,
-                          &atomsInPlay, &bondsInPlay);
+                          includeRingStereo, &atomsInPlay, &bondsInPlay);
 
   for (unsigned int i = 0; i < mol.getNumAtoms(); ++i) {
     res[order[i]] = atoms[order[i]].index;
diff --git a/Code/GraphMol/new_canon.h b/Code/GraphMol/new_canon.h
index f47a3c12b..9c56613eb 100644
--- a/Code/GraphMol/new_canon.h
+++ b/Code/GraphMol/new_canon.h
@@ -179,12 +179,15 @@ class RDKIT_GRAPHMOL_EXPORT SpecialChiralityAtomCompareFunctor {
     if (!dp_atomsInPlay || (*dp_atomsInPlay)[j]) {
       updateAtomNeighborNumSwaps(dp_atoms, dp_atoms[j].bonds, j, swapsj);
     }
+
     for (unsigned int ii = 0; ii < swapsi.size() && ii < swapsj.size(); ++ii) {
       int cmp = swapsi[ii].second - swapsj[ii].second;
+
       if (cmp) {
         return cmp;
       }
     }
+
     return 0;
   }
 };
@@ -852,7 +855,8 @@ RDKIT_GRAPHMOL_EXPORT void rankMolAtoms(
     const ROMol &mol, std::vector<unsigned int> &res, bool breakTies = true,
     bool includeChirality = true, bool includeIsotopes = true,
     bool includeAtomMaps = true, bool includeChiralPresence = false,
-    bool includeStereoGroups = true, bool useNonStereoRanks = false);
+    bool includeStereoGroups = true, bool useNonStereoRanks = false,
+    bool includeRingStereo = true);
 
 //! Note that atom maps on dummy atoms will always be used
 RDKIT_GRAPHMOL_EXPORT void rankFragmentAtoms(
@@ -862,7 +866,7 @@ RDKIT_GRAPHMOL_EXPORT void rankFragmentAtoms(
     const std::vector<std::string> *atomSymbols,
     const std::vector<std::string> *bondSymbols, bool breakTies,
     bool includeChirality, bool includeIsotope, bool includeAtomMaps,
-    bool includeChiralPresence);
+    bool includeChiralPresence, bool includeRingStereo = true);
 
 //! Note that atom maps on dummy atoms will always be used
 inline void rankFragmentAtoms(
@@ -872,10 +876,10 @@ inline void rankFragmentAtoms(
     const std::vector<std::string> *atomSymbols = nullptr,
     bool breakTies = true, bool includeChirality = true,
     bool includeIsotopes = true, bool includeAtomMaps = true,
-    bool includeChiralPresence = false) {
+    bool includeChiralPresence = false, bool includeRingStereo = true) {
   rankFragmentAtoms(mol, res, atomsInPlay, bondsInPlay, atomSymbols, nullptr,
                     breakTies, includeChirality, includeIsotopes,
-                    includeAtomMaps, includeChiralPresence);
+                    includeAtomMaps, includeChiralPresence, includeRingStereo);
 };
 
 RDKIT_GRAPHMOL_EXPORT void chiralRankMolAtoms(const ROMol &mol,
@@ -898,6 +902,7 @@ void initFragmentCanonAtoms(const ROMol &mol,
 template <typename T>
 void rankWithFunctor(T &ftor, bool breakTies, int *order,
                      bool useSpecial = false, bool useChirality = false,
+                     bool includeRingStereo = true,
                      const boost::dynamic_bitset<> *atomsInPlay = nullptr,
                      const boost::dynamic_bitset<> *bondsInPlay = nullptr);
 
