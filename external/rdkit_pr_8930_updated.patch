diff --git a/Code/GraphMol/Chirality.cpp b/Code/GraphMol/Chirality.cpp
index c7c5d4af1..e3ca34cf0 100644
--- a/Code/GraphMol/Chirality.cpp
+++ b/Code/GraphMol/Chirality.cpp
@@ -426,7 +426,7 @@ namespace Chirality {
 
 std::optional<Atom::ChiralType> atomChiralTypeFromBondDirPseudo3D(
     const ROMol &mol, const Bond *bond, const Conformer *conf,
-    double pseudo3DOffset = 0.1, double volumeTolerance = 0.01) {
+    double pseudo3DOffset = 0.1) {
   PRECONDITION(bond, "no bond");
   PRECONDITION(conf, "no conformer");
   auto bondDir = bond->getBondDir();
@@ -434,6 +434,13 @@ std::optional<Atom::ChiralType> atomChiralTypeFromBondDirPseudo3D(
                "bad bond direction");
   constexpr double coordZeroTol = 1e-4;
   constexpr double zeroTol = 1e-3;
+  constexpr double tShapeTol =
+      0.00031;  // used to recognize T-shaped arrangements
+  // corresponds to an angle between the two vectors of just under 178 degrees
+  // degree
+  constexpr double volumeTolerance =
+      0.00174;  // used to recognize zero chiral volume
+  // This is what we get for a T-shaped arrangement with just over 178 degrees
 
   // NOTE that according to the CT file spec, wedging assigns chirality
   // to the atom at the point of the wedge, (atom 1 in the bond).
@@ -756,7 +763,7 @@ std::optional<Atom::ChiralType> atomChiralTypeFromBondDirPseudo3D(
     auto crossp1 = bv1.crossProduct(bv2);
     // catch linear arrangements
     if (nNbrs == 3) {
-      if (crossp1.lengthSq() < 5 * zeroTol) {
+      if (crossp1.lengthSq() < tShapeTol) {
         // in a linear relationship with three neighbors we assume that the
         // two perpendicular bonds are wedged in the other direction from the
         // one that was provided.
@@ -3019,10 +3026,10 @@ void findPotentialStereoBonds(ROMol &mol, bool cleanIt) {
               }
             }  // end of check that beg and end atoms have at least 1
                // neighbor:
-          }    // end of 2 and 3 coordinated atoms only
-        }      // end of we want it or CIP code is not set
-      }        // end of double bond
-    }          // end of for loop over all bonds
+          }  // end of 2 and 3 coordinated atoms only
+        }  // end of we want it or CIP code is not set
+      }  // end of double bond
+    }  // end of for loop over all bonds
     mol.setProp(common_properties::_BondsPotentialStereo, 1, true);
   }
 }
diff --git a/Code/GraphMol/WedgeBonds.cpp b/Code/GraphMol/WedgeBonds.cpp
index 08e4060f6..413ea3d43 100644
--- a/Code/GraphMol/WedgeBonds.cpp
+++ b/Code/GraphMol/WedgeBonds.cpp
@@ -210,7 +210,10 @@ Bond::BondDir determineBondWedgeState(const Bond *bond,
     double angle1 = (*angleIt);
     ++angleIt;
     double angle2 = (*angleIt);
-    if (angle2 - angle1 >= (M_PI - 1e-4)) {
+    constexpr double angleTol =
+        M_PI * 1.9 / 180.;  // just under 2 degrees tolerance, which is what we
+                            // use when perceiving T-shaped geometries
+    if (angle2 - angle1 >= (M_PI - angleTol)) {
       // we have the above situation
       nSwaps++;
     }
